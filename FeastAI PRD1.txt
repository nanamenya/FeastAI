FeastAI - Product Requirements Document
1. Overview
1.1 Product Vision
FeastAI is a Progressive Web App (PWA) that helps users coordinate multi-dish meal preparation by generating optimized cooking schedules. The app ensures all dishes are ready at the target serving time while minimizing total preparation time and managing limited cooking appliances.
1.2 Target Users
	â€¢	Home cooks preparing dinner parties or holiday meals with multiple dishes
	â€¢	Anyone coordinating complex meals with limited kitchen resources
	â€¢	Users comfortable with basic technology and recipe websites
1.3 Core Value Proposition
Eliminates the stress of timing multiple dishes by providing a clear, visual schedule that accounts for appliance constraints and ensures hot dishes arrive hot at serving time.

2. Product Phases
Phase 1 (MVP)
Manual recipe entry, basic scheduling algorithm, read-only schedule visualization.
Phase 2
LLM-powered recipe extraction (user-provided Gemini API key), editable schedule grid with drag-and-drop.
Phase 3
Advanced features: recipe library, schedule sharing, mobile optimizations.

3. Functional Requirements
3.1 Recipe Management
3.1.1 Recipe Entry (Phase 1 - Manual)
	â€¢	Input Fields:
	â€¢	Dish name (text, required)
	â€¢	Recipe URL (text, optional - for reference only)
	â€¢	Serving requirement: Hot/Cold (radio button, required)
	â€¢	Priority for hot dishes: High/Medium/Low (dropdown, required if Hot)
	â€¢	Cooking Steps: Users can add multiple cooking steps per recipe
	â€¢	Step name (text, required)
	â€¢	Appliance required (dropdown: Stovetop Burner, Oven, Microwave, Prep, required)
	â€¢	Cooking time in minutes (number, required)
	â€¢	Temperature (number with unit selector Â°F/Â°C, optional)
	â€¢	Dependencies: "Must complete after" another step (dropdown of previous steps, optional)
	â€¢	Aggregated Prep Block:
	â€¢	Each recipe automatically gets one "Prep" block
	â€¢	Default: 15 minutes if not specified
	â€¢	User can edit prep time
	â€¢	Prep block represents ALL prep activities (chopping, measuring, mixing, etc.) aggregated into one task
	â€¢	Prep block does not require an appliance
3.1.2 Recipe Entry (Phase 2 - LLM-Assisted)
	â€¢	User pastes recipe URL
	â€¢	System uses Gemini API to extract: 
	â€¢	Dish name
	â€¢	All cooking steps with appliance, time, temperature
	â€¢	Sequential dependencies between steps
	â€¢	Aggregated prep time (if not specified in recipe, default to 15 minutes)
	â€¢	Hot/Cold serving requirement (inferred from dish type)
	â€¢	User reviews and confirms/edits extracted data before saving
	â€¢	If LLM extraction fails, fall back to manual entry
3.1.3 Recipe Storage
	â€¢	Recipes stored in browser LocalStorage
	â€¢	Users can save, edit, and delete recipes
	â€¢	Recipe list view showing all saved recipes
3.2 Kitchen Configuration
3.2.1 Appliance Setup
	â€¢	Users define their kitchen setup: 
	â€¢	Number of stovetop burners (default: 4)
	â€¢	Number of ovens (default: 1)
	â€¢	Number of microwaves (default: 1)
	â€¢	Configuration saved to LocalStorage
	â€¢	Can be edited at any time
	â€¢	Each burner/oven/microwave treated as a separate resource
3.3 Meal Planning
3.3.1 Meal Setup
	â€¢	User selects multiple recipes from saved library
	â€¢	User specifies target serving time (time picker)
	â€¢	System validates that scheduling is feasible given appliance constraints
3.3.2 Schedule Generation
	â€¢	Optimization Goal: Minimize total elapsed time (start cooking as late as possible while meeting target serving time)
	â€¢	Scheduling Algorithm:
	â€¢	Parse all cooking steps and dependencies across all dishes
	â€¢	Identify critical path (longest sequence of dependent steps)
	â€¢	Work backwards from target serving time
	â€¢	Schedule steps respecting: 
	â€¢	Appliance constraints (one task per appliance at a time)
	â€¢	Step dependencies (sequential steps within recipes)
	â€¢	Prep blocks (must complete before cooking steps for that recipe)
	â€¢	Hot dish priority (highest priority hot dish finishes exactly at target time)
	â€¢	Cold dishes (can finish earlier than target time)
	â€¢	Assign specific appliances to each step
	â€¢	Generate start times for each step
	â€¢	Constraint Handling:
	â€¢	If no feasible schedule exists, inform user with reason: 
	â€¢	"Too many dishes require the same appliance simultaneously"
	â€¢	"Not enough time to complete all dishes before target serving time"
	â€¢	"Step dependencies create impossible timing requirements"
3.4 Schedule Visualization
3.4.1 Grid Display (Phase 1 - Read-Only)
	â€¢	Horizontal axis: Time in 5-minute blocks
	â€¢	Start time determined by algorithm
	â€¢	End time = target serving time
	â€¢	Current time marker if viewing during cooking
	â€¢	Vertical axis: Resources (rows)
	â€¢	One row labeled "Prep" for all prep activities
	â€¢	One row per stovetop burner (Burner 1, Burner 2, etc.)
	â€¢	One row per oven (Oven 1, etc.)
	â€¢	One row per microwave (Microwave 1, etc.)
	â€¢	Task Blocks:
	â€¢	Each task displayed as colored block overlaid on grid
	â€¢	Block width = task duration (scaled to 5-min blocks)
	â€¢	Block shows: Dish name, step name, time duration
	â€¢	Color-coded by dish (each recipe gets unique color)
	â€¢	Hot dishes marked with ðŸ”¥ icon
	â€¢	High-priority hot dishes have bold border
	â€¢	Visual Indicators:
	â€¢	Dependencies shown with arrows between blocks
	â€¢	Target serving time marked with vertical line
	â€¢	Gaps/idle time visible as empty grid space
3.4.2 Editable Grid (Phase 2)
	â€¢	Drag-and-Drop:
	â€¢	Users can drag task blocks horizontally (change start time)
	â€¢	Users can drag task blocks vertically (change appliance, if same type)
	â€¢	Real-time collision detection
	â€¢	Validation:
	â€¢	Invalid states clearly marked in red: 
	â€¢	Overlapping tasks on same appliance
	â€¢	Dependencies violated (step starts before prerequisite completes)
	â€¢	Hot dishes finishing after target time
	â€¢	Error messages displayed next to invalid blocks
	â€¢	Schedule cannot be saved/used if invalid
	â€¢	Manual Adjustments:
	â€¢	Users can manually edit task start times
	â€¢	Users can reassign tasks to different appliances (same type)
	â€¢	Changes trigger re-validation
3.4.3 Schedule Export
	â€¢	Print-friendly view
	â€¢	Export as image (PNG)
	â€¢	Export as text list with times
3.5 Cooking Mode
3.5.1 Active Schedule View
	â€¢	Current time indicator moves across grid in real-time
	â€¢	Highlight next task(s) to start
	â€¢	Mark completed tasks (user can check off)
	â€¢	Push notifications (if PWA permissions granted): 
	â€¢	5 minutes before each task starts
	â€¢	When task should be starting

4. Technical Architecture
4.1 Technology Stack
	â€¢	Frontend: React with TypeScript
	â€¢	State Management: React Context API or Zustand
	â€¢	Styling: Tailwind CSS for responsive design
	â€¢	Grid Visualization: Custom HTML5 Canvas or SVG, or react-grid-layout library
	â€¢	LLM Integration (Phase 2): Google Gemini API
	â€¢	Storage: Browser LocalStorage
	â€¢	PWA: Workbox for service worker, Web App Manifest
4.2 Data Models
Recipe
interface Recipe {
  id: string;
  name: string;
  url?: string;
  servingRequirement: 'hot' | 'cold';
  hotPriority?: 'high' | 'medium' | 'low'; // required if hot
  prepTime: number; // minutes, default 15
  steps: CookingStep[];
}
CookingStep
interface CookingStep {
  id: string;
  recipeId: string;
  name: string;
  appliance: 'prep' | 'burner' | 'oven' | 'microwave';
  duration: number; // minutes
  temperature?: number;
  temperatureUnit?: 'F' | 'C';
  dependsOn?: string[]; // array of step IDs that must complete first
}
KitchenConfig
interface KitchenConfig {
  burners: number;
  ovens: number;
  microwaves: number;
}
ScheduledTask
interface ScheduledTask {
  stepId: string;
  recipeId: string;
  recipeName: string;
  stepName: string;
  appliance: string;
  applianceInstance: number; // which specific burner/oven
  startTime: Date;
  endTime: Date;
  duration: number;
  isHot: boolean;
  priority?: string;
  dependencies: string[];
}
Schedule
interface Schedule {
  id: string;
  targetTime: Date;
  recipes: Recipe[];
  tasks: ScheduledTask[];
  totalElapsedTime: number; // minutes
  isValid: boolean;
  validationErrors?: string[];
}
4.3 Scheduling Algorithm Pseudocode
function generateSchedule(recipes, kitchenConfig, targetTime):
  // 1. Collect all steps and prep blocks
  allSteps = []
  for each recipe:
    add prepBlock(recipe, duration=recipe.prepTime, appliance='prep')
    for each step in recipe.steps:
      allSteps.add(step)
  
  // 2. Build dependency graph
  dependencyGraph = buildGraph(allSteps)
  
  // 3. Topological sort to get valid ordering
  orderedSteps = topologicalSort(dependencyGraph)
  
  // 4. Calculate earliest start times (forward pass)
  for each step in orderedSteps:
    if step has no dependencies:
      step.earliestStart = 0
    else:
      step.earliestStart = max(dependency.earliestFinish for all dependencies)
    step.earliestFinish = step.earliestStart + step.duration
  
  // 5. Calculate latest start times (backward pass from target)
  criticalPath = findLongestPath(dependencyGraph)
  totalMinTime = criticalPath.duration
  
  // Identify highest priority hot dish
  primaryHotDish = findHighestPriorityHotDish(recipes)
  
  for each step in reverse(orderedSteps):
    if step is final step of primaryHotDish:
      step.latestFinish = targetTime
    else if step is final step of hot dish:
      step.latestFinish = targetTime
    else if step is final step of cold dish:
      step.latestFinish = targetTime // can finish earlier during scheduling
    else:
      step.latestFinish = min(successor.latestStart for all successors)
    
    step.latestStart = step.latestFinish - step.duration
  
  // 6. Schedule tasks using list scheduling heuristic
  schedule = []
  resources = initializeResources(kitchenConfig)
  timeSlots = createTimeSlots(targetTime - totalMinTime, targetTime, interval=5min)
  
  for each timeSlot:
    // Find tasks ready to execute (dependencies met, not yet scheduled)
    readyTasks = findReadyTasks(orderedSteps, schedule, timeSlot)
    
    // Sort by priority: hot > cold, high priority > low, earliest latestStart first
    sortByPriority(readyTasks)
    
    for each task in readyTasks:
      resource = findAvailableResource(resources, task.appliance, timeSlot)
      if resource:
        assignTask(schedule, task, resource, timeSlot)
  
  // 7. Validate schedule
  errors = validateSchedule(schedule, recipes, targetTime)
  
  return {schedule, errors}

function validateSchedule(schedule, recipes, targetTime):
  errors = []
  
  // Check for appliance conflicts
  for each timeSlot:
    for each appliance:
      if countTasksOnAppliance(schedule, appliance, timeSlot) > 1:
        errors.add("Appliance conflict at " + timeSlot)
  
  // Check dependencies satisfied
  for each task in schedule:
    for each dependency:
      if dependency.endTime > task.startTime:
        errors.add("Dependency violation for " + task.name)
  
  // Check hot dishes finish on time
  for each recipe where servingRequirement == 'hot':
    finalTask = findFinalTask(schedule, recipe)
    if finalTask.endTime > targetTime:
      errors.add(recipe.name + " finishes after target time")
  
  return errors
4.4 LLM Integration (Phase 2)
Recipe Extraction Prompt Template
You are a cooking assistant. Extract structured information from this recipe.

Recipe URL: {url}
Recipe Text: {text}

Extract the following in JSON format:
{
  "dishName": "string",
  "servingRequirement": "hot" or "cold",
  "prepTime": number (minutes, default 15 if not specified),
  "steps": [
    {
      "name": "string (brief description)",
      "appliance": "burner" | "oven" | "microwave",
      "duration": number (minutes),
      "temperature": number (optional),
      "temperatureUnit": "F" | "C" (optional),
      "dependsOn": [array of previous step names that must complete first]
    }
  ]
}

Guidelines:
- Aggregate all prep activities (chopping, mixing, measuring) into the single prepTime value
- Only include cooking steps that require appliances (burner/oven/microwave)
- Identify sequential dependencies (e.g., "make sauce" must complete before "add sauce to pasta")
- If a recipe has multiple cooking stages with the same appliance, create separate steps
- Infer appliance from cooking method (sautÃ©â†’burner, bakeâ†’oven, reheatâ†’microwave)
API Implementation
async function extractRecipe(url: string, apiKey: string): Promise<Recipe> {
  // 1. Fetch recipe content (may need web scraping)
  const recipeText = await fetchRecipeContent(url);
  
  // 2. Call Gemini API
  const response = await fetch('https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-goog-api-key': apiKey
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: EXTRACTION_PROMPT_TEMPLATE
            .replace('{url}', url)
            .replace('{text}', recipeText)
        }]
      }]
    })
  });
  
  // 3. Parse JSON response
  const data = await response.json();
  const extracted = JSON.parse(data.candidates[0].content.parts[0].text);
  
  // 4. Convert to Recipe object
  return {
    id: generateId(),
    name: extracted.dishName,
    url: url,
    servingRequirement: extracted.servingRequirement,
    hotPriority: extracted.servingRequirement === 'hot' ? 'medium' : undefined,
    prepTime: extracted.prepTime || 15,
    steps: extracted.steps.map(step => ({
      id: generateId(),
      recipeId: '', // assigned after recipe created
      name: step.name,
      appliance: step.appliance,
      duration: step.duration,
      temperature: step.temperature,
      temperatureUnit: step.temperatureUnit,
      dependsOn: [] // resolved after all steps created
    }))
  };
}

5. User Interface Design
5.1 Screen Flow
	â€¢	Home Screen: New meal, Saved recipes, Kitchen config
	â€¢	Recipe Entry: Manual form or URL input (Phase 2)
	â€¢	Meal Setup: Select recipes, set target time
	â€¢	Schedule View: Grid visualization
	â€¢	Cooking Mode: Live schedule with current time
5.2 Key UI Components
Recipe Form
	â€¢	Clean, step-by-step form
	â€¢	"Add Step" button to add multiple cooking steps
	â€¢	Dependency selector shows only previous steps
	â€¢	Visual preview of recipe structure
Kitchen Config Screen
	â€¢	Simple number inputs for appliance counts
	â€¢	Visual icons for each appliance type
	â€¢	Save/Cancel buttons
Schedule Grid
	â€¢	Responsive design (horizontal scroll on mobile)
	â€¢	Zoom controls (+/- buttons)
	â€¢	Legend showing dish colors and icons
	â€¢	Time axis with clear labels every 15-30 minutes
	â€¢	Resource labels on left side
	â€¢	Grid lines every 5 minutes (light) and 15 minutes (bold)
Cooking Mode
	â€¢	Large, clear "Next Up" section
	â€¢	Checklist of tasks
	â€¢	Timer integration
	â€¢	Pause/Resume capability
5.3 Responsive Design
	â€¢	Desktop: Full grid view, side-by-side recipe list and schedule
	â€¢	Tablet: Collapsible recipe list, full-width grid
	â€¢	Mobile: 
	â€¢	Vertical scrolling priority
	â€¢	Condensed grid (smaller blocks)
	â€¢	Swipe gestures for navigation
	â€¢	Bottom sheet for task details

6. Non-Functional Requirements
6.1 Performance
	â€¢	Schedule generation: < 3 seconds for up to 10 recipes
	â€¢	Grid rendering: < 1 second for schedules up to 3 hours
	â€¢	PWA loads offline after first visit
6.2 Usability
	â€¢	Intuitive for users with basic cooking and tech literacy
	â€¢	No more than 3 clicks to generate a schedule
	â€¢	Clear error messages with actionable guidance
	â€¢	Works without internet (except LLM features)
6.3 Browser Support
	â€¢	Chrome/Edge: Last 2 versions
	â€¢	Safari: Last 2 versions
	â€¢	Firefox: Last 2 versions
	â€¢	Mobile browsers: iOS Safari 14+, Chrome Android
6.4 Data Privacy
	â€¢	All data stored locally (no server)
	â€¢	User-provided API keys stored securely in LocalStorage
	â€¢	No analytics or tracking (optional: privacy-preserving analytics)
6.5 Accessibility
	â€¢	WCAG 2.1 AA compliance
	â€¢	Keyboard navigation support
	â€¢	Screen reader compatibility
	â€¢	Color-blind friendly color scheme
	â€¢	High contrast mode option

7. Future Enhancements (Phase 3+)
7.1 Advanced Features
	â€¢	Recipe scaling: Adjust serving sizes, recalculate times
	â€¢	Recipe sharing: Export/import recipes as JSON
	â€¢	Meal templates: Save common meal combinations
	â€¢	Multi-oven support: Handle different oven temperatures simultaneously
	â€¢	Keep-warm capabilities: Schedule dishes to finish early and keep warm
	â€¢	Shopping list generator: Extract ingredients from all recipes
7.2 Social Features
	â€¢	Schedule sharing: Share schedules via link
	â€¢	Recipe database: Community-contributed recipes
	â€¢	Comments and ratings: User feedback on recipes
7.3 Intelligence Improvements
	â€¢	Learning: Adjust default times based on user's historical edits
	â€¢	Smart suggestions: Recommend dishes that pair well timing-wise
	â€¢	Conflict resolution: AI-powered suggestions to resolve scheduling conflicts
7.4 Integrations
	â€¢	Recipe websites: Direct integration with popular recipe sites
	â€¢	Smart appliances: Send schedules to smart ovens/ranges
	â€¢	Calendar: Add meal prep blocks to Google/Apple Calendar
	â€¢	Voice assistants: "Alexa, what's next on my FeastAI schedule?"

8. Success Metrics
8.1 MVP Success Criteria
	â€¢	Users can create and save recipes manually
	â€¢	Users can generate valid schedules for 3-5 dish meals
	â€¢	Schedule visualization is clear and readable
	â€¢	90% of schedules generate in < 3 seconds
8.2 Phase 2 Success Criteria
	â€¢	80% of recipe extractions require no manual editing
	â€¢	Users successfully edit and save modified schedules
	â€¢	< 5% of dragged tasks result in invalid states
8.3 Long-term Metrics
	â€¢	Monthly active users
	â€¢	Average recipes per user
	â€¢	Average meal complexity (number of dishes)
	â€¢	User retention (return within 30 days)
	â€¢	Feature adoption rates

9. Development Phases
Phase 1: MVP (4-6 weeks)
Week 1-2: Core data models, recipe management, kitchen config Week 3-4: Scheduling algorithm implementation and testing Week 5: Grid visualization (read-only) Week 6: PWA setup, testing, bug fixes
Phase 2: LLM & Editing (3-4 weeks)
Week 1: Gemini API integration, recipe extraction Week 2-3: Editable grid with drag-and-drop Week 4: Validation, testing, refinement
Phase 3: Polish & Advanced Features (Ongoing)
	â€¢	Cooking mode with timers
	â€¢	Export/sharing capabilities
	â€¢	Mobile optimizations
	â€¢	Advanced scheduling features

10. Open Questions & Risks
10.1 Open Questions
	â€¢	Should prep blocks be per-recipe or aggregate all prep? 
	â€¢	Decision: Per-recipe, shown on "Prep" row
	â€¢	How to handle recipes with unclear appliance requirements? 
	â€¢	Decision: Force user to specify during manual review
	â€¢	Should temperature conflicts in ovens be flagged? 
	â€¢	Decision: Phase 1 assumes one dish per oven; Phase 3 can add multi-temp support
10.2 Technical Risks
	â€¢	Scheduling complexity: For complex meals (10+ dishes), algorithm may not find optimal solutions 
	â€¢	Mitigation: Implement heuristics, set maximum meal complexity for MVP
	â€¢	LLM accuracy: Recipe extraction may fail or be inaccurate 
	â€¢	Mitigation: Always allow manual review and editing
	â€¢	Browser compatibility: LocalStorage limits, PWA support varies 
	â€¢	Mitigation: Implement storage quotas, graceful degradation
10.3 User Experience Risks
	â€¢	Learning curve: Grid visualization may be confusing initially 
	â€¢	Mitigation: Add onboarding tutorial, tooltips
	â€¢	Mobile usability: Complex grid may not work well on small screens 
	â€¢	Mitigation: Design mobile-first alternative view (list-based)

11. Appendix
11.1 Glossary
	â€¢	Appliance: Physical cooking device (burner, oven, microwave)
	â€¢	Step: Single cooking action within a recipe
	â€¢	Prep block: Aggregated preparation time for a recipe (non-appliance work)
	â€¢	Dependency: Requirement that one step must complete before another starts
	â€¢	Target time: Desired serving time for the meal
	â€¢	Critical path: Longest sequence of dependent steps determining minimum total time
11.2 References
	â€¢	Job Shop Scheduling Problem: https://en.wikipedia.org/wiki/Job-shop_scheduling
	â€¢	PWA Best Practices: https://web.dev/progressive-web-apps/
	â€¢	Gemini API Documentation: https://ai.google.dev/docs
11.3 Example Use Case
Scenario: Thanksgiving dinner with 4 dishes
	â€¢	Turkey (hot, high priority): 3 hours in oven
	â€¢	Mashed potatoes (hot, medium): 15 min prep, 30 min boil on burner
	â€¢	Green beans (hot, low): 10 min prep, 15 min sautÃ© on burner
	â€¢	Cranberry sauce (cold): 10 min prep, 20 min simmer on burner
Kitchen: 4 burners, 1 oven Target time: 6:00 PM
Generated Schedule:
	â€¢	2:45 PM: Start turkey in oven
	â€¢	5:00 PM: Prep cranberry sauce (15 min)
	â€¢	5:15 PM: Cook cranberry sauce on Burner 1 (20 min, finishes 5:35 PM)
	â€¢	5:20 PM: Prep green beans (10 min)
	â€¢	5:30 PM: Prep mashed potatoes (15 min)
	â€¢	5:45 PM: Turkey done, remove from oven
	â€¢	5:45 PM: Boil potatoes on Burner 2 (30 min)
	â€¢	5:45 PM: SautÃ© green beans on Burner 3 (15 min)
	â€¢	6:00 PM: All hot dishes ready, serve!
Total elapsed time: 3 hours 15 minutes (2:45 PM - 6:00 PM) Appliance utilization: Oven: 3 hrs, Burners: minimal overlap, efficient use

